## 9. AI Agent Specific Instructions
*Comment: This section provides overarching directives for the AI Coding Agent. Adherence to these instructions is critical for the success of the Agentic Coding System.*

### 9.1. Feature Decomposition and Specification Process (Mandatory Pre-Coding Step for AI)
*AI Agent Directive: For every high-level feature provided by the user in Section 3.1, before commencing any code implementation, you MUST perform the following decomposition and specification process. The objective is to ensure your exhaustive and unambiguous understanding of each task, aligning with our 'Argentic Coding' standards. Generate this detailed specification internally or in a working document that can be reviewed by humans. **This includes proposing specific libraries, backend services (e.g., Supabase services if chosen), or MCP servers where appropriate.** Your proposals for tooling (MCPs, libraries, specific backend services) are crucial and require human validation. This decomposition process is critical for your reasoning. Break down complex problems into smaller, manageable sub-problems. For each sub-problem, consider the relevant sections of this PRD (NFRs, Design System, MCP Logic, etc.) before proposing a solution.*

**Detailed Specification Structure to be Generated by AI Agent (for each User-Provided Feature):**

1.  **`feature_id` (Unique Feature Identifier):**
    *   *AI Instruction:* Assign a unique ID (e.g., `FEAT-001`).
2.  **`user_story_reiteration` (User Story/Stories):**
    *   *AI Instruction:* Based on the user's high-level feature description, formulate the primary user story (or stories).
3.  **`description_expanded_by_ai` (AI's Detailed Understanding):**
    *   *AI Instruction:* Elaborate on the user's description. Clarify objectives, expected outcomes, integration points. Anticipate interactions and edge cases.
4.  **`acceptance_criteria_generated_by_ai` (AI-Generated Acceptance Criteria):**
    *   *AI Instruction:* Derive exhaustive acceptance criteria in Gherkin format. Cover nominal, error, and boundary cases.
    *   *AI Resources:* Project business rules, NFRs.
    5.  **`ui_elements_and_styling_plan_by_ai` (UI Elements and Styling Plan - Objective: YC Standard Excellence):**
        *   *AI Instruction:* Identify UI elements. Propose `element_type` and `component_base` (Storybook/Shadcn). Identify `tailwind_tokens_to_use` from [`tailwind.config.js`](tailwind.config.js:1). Describe layout, responsiveness, interactions. **Your proposals must imperatively aim for the "Silicon Valley / Y Combinator" design objective: modernity, elegance, fluidity, and an impeccable user experience. If the user has not provided aesthetic preferences, propose a style that embodies this ideal (minimalist, refined typography, etc.). If complexity justifies it AND the human explicitly requests it (Section 1.11), be prepared to propose 2-3 initial design variations for key UI elements of a feature to facilitate rapid exploration. Clearly label these proposals as 'exploratory design variations'.**
        *   *AI Resources:* [`tailwind.config.js`](tailwind.config.js:1), Storybook, Agentic Design Principles (with YC objective), user's aesthetic input.
    6.  **`data_and_logic_plan_by_ai` (Data and Logic Plan):**
        *   `input_data_identified`: List inputs, types, validation rules (client/server), error messages.
    *   `backend_interaction_strategy`: Detail interaction with the chosen backend (e.g., Supabase: DB, Auth, Edge Functions for custom logic). Specify tables, security considerations (like RLS if applicable), function signatures, request/response payloads.
    *   `frontend_state_management_approach`: Propose client-side state management suitable for the chosen frontend framework.
    *   *AI Resources:* Chosen database schema (you will propose this if not user-defined), API docs, state conventions.
7.  **`error_handling_strategy_by_ai` (Error Handling Strategy):**
    *   *AI Instruction:* Identify failure points (network, DB, APIs). Describe error catching, logging, user communication (aligned with Design System).
8.  **`security_checks_required_by_ai` (Security Checks):**
    *   *AI Instruction:* List security measures (input sanitization, RLS, XSS/CSRF protection for custom endpoints, etc.).
    *   *AI Resources:* OWASP Top 10, security best practices for the chosen backend (e.g., Supabase).
9.  **`dependencies_identified_by_ai` (Dependencies, including MCPs & Services):**
    *   *AI Instruction:* List project modules, external services, **MCP Servers** (e.g., `stripe` MCP, `context7` MCP, `supabase` MCP, `github` MCP), specific **backend services** (e.g., Supabase Auth, Storage, Functions, Realtime, Vector DB if Supabase is chosen), or third-party libraries/APIs. Task management is handled by Roo Orchestrator/Code (see [`../../../02_AI-DOCS/TaskManagement/Roo_Task_Workflow.md`](../../../02_AI-DOCS/TaskManagement/Roo_Task_Workflow.md)). **Provide justification for each proposed tool/service and how it integrates. When proposing an MCP server, specify its known capabilities, the primary function it will serve, and if it's a standard known MCP or one that would require setup/connection instructions from the user (if new/unknown, explicitly ask user for API docs/connection details). Confirm that its implementation will follow the 'Standard MCP Integration Logic' (Section 9.9).**
10. **`questions_for_clarification_by_ai` (Questions for Human Clarification):**
    *   *AI Instruction:* If ambiguities remain, list specific questions for the human team. **Do not code ambiguous parts without clarification.**

**General Directives for AI Agent During Implementation:**
*   Strict Adherence to Agentic Coding System.
*   Modular and Testable Code.
*   Relevant Comments.
*   Robust Error Handling.
*   Performance and Accessibility.

### 9.2. Coding Style and Linters
*AI Instruction: Adhere to ESLint with `@next/eslint-plugin-next` and Prettier (default settings or project-specific config if provided). Ensure all generated code passes these checks before considering a task complete.*
`[User can specify alternative linter/formatter configs if necessary]`

### 9.3. Dependency Management
*AI Instruction: Manage dependencies via `package.json` using `npm` (or `yarn`/`pnpm` if specified by user). Update `package.json` correctly when adding new dependencies (e.g., `npm install --save <package>`).*
`[User can specify package manager preference]`

### 9.4. Code Documentation Generation
*AI Instruction: Generate JSDoc comments for all functions and React components (props, purpose). Generate Storybook stories for all UI components. Ensure TypeScript types are clear and descriptive.*
`[User can specify additional code documentation standards]`

### 9.5. Commit and Versioning Strategy
*AI Instruction: Use Conventional Commits format for all commits (e.g., `feat: add user login page`, `fix: correct validation error on signup`). Generate clear and concise commit messages reflecting the changes made. Versioning (SemVer) will be handled by humans.*
`[User can specify variations to commit strategy if needed]`

### 9.6. Feedback Loop and Self-Correction
*AI Instruction: Upon encountering build errors, test failures, or linter issues, first attempt to self-correct based on the error messages and context. Make up to 3 self-correction attempts for a given logical issue. If self-correction fails after 3 attempts on the same logical issue, escalate to human review with detailed logs of attempts and errors, then await further instruction. Do not proceed with potentially flawed code.*
`[User can adjust self-correction parameters]`

### 9.7. AI Initiative in Tooling, MCP Server, and Service Selection
*AI Instruction: You are expected to proactively identify, evaluate, and propose the use of relevant tools and services.*

#### 9.7.1. Protocol for Proposing and Learning New Tools/MCPs
*AI Agent Directive: If you identify the need for a new tool, library, or MCP not currently listed or known to the project (see Section 5.6.1):*
    1.  *Describe the specific need and explain why existing project tools, connected MCPs, or chosen backend features (e.g., Supabase) are insufficient.*
    2.  *If you can identify a potential solution (e.g., a specific library, an existing third-party API, a known public MCP), provide a link to its official documentation and a brief summary of its relevance.*
    3.  *Explicitly ask the human user to validate the proposed tool/service.*
    4.  *If approved, request necessary configuration details from the user for the new tool/MCP, such as: API Endpoint, Authentication Method (and where to securely access credentials), Key request/response structures, Rate limits or quotas, Link to official detailed documentation.*
    5.  *Once approved and configured (potentially with human assistance for setup), you may add this tool/MCP to your 'knowledge base' for this project (e.g., by suggesting an update to Section 5.6.1 or an internal project knowledge document).*

*AI Instruction (General for 9.7):*
    *   **MCP Servers:** Utilize known, available MCPs (listed in 5.6.1) for specialized tasks. For new MCP needs, follow protocol 9.7.1.
    *   **Third-Party APIs & Libraries:** For functionalities not covered by the core stack or Supabase. Follow protocol 9.7.1 for new additions.
    *   **Chosen Backend Ecosystem:** If a BaaS like Supabase is chosen, fully leverage its features (Auth, DB, Storage, Edge Functions, Realtime, Vector DB) as a primary choice before proposing external tools.
*Document all proposals with rationale in your feature specifications (Section 9.1.9) for human review and approval. Prioritize robust, secure, well-maintained, and (where possible) cost-effective solutions compatible with the chosen technology stack (e.g., Next.js/Supabase or alternatives).*
`[This section empowers the AI but mandates human oversight for new tooling, especially non-standard MCPs/APIs]`

### 9.8. Workflow with Assisted Coding Tools (e.g., Cursor, Cline)
*AI Agent Directive: "When interacting with human developers via tools like Cursor or Cline, or any similar conversational coding assistant interface:*
    1.  *Be prepared to receive instructions and generate code in a conversational, iterative manner. Expect prompts to be less formal than full PRD specifications at times.*
    2.  *Utilize your comprehensive understanding of this PRD (including user-provided 'vibes', design principles, and technical constraints) to provide context-aware suggestions, code snippets, and complete components.*
    3.  *When asked to 'try something,' 'explore an idea,' or generate alternatives, leverage the 'Embrace Iterative Exploration' Guiding Principle (Section 1.8) and the Agentic Coding System to inform your proposals. Prioritize speed of generation for these exploratory tasks.*
    4.  *Facilitate rapid prototyping by generating functional (even if not initially fully polished or tested to production standards) code blocks quickly when in an exploratory context.*
    5.  *Clearly indicate when a generated piece of code is a 'draft for exploration/vibe check' versus a 'production-ready proposal based on full PRD specs and requiring all standard quality checks'. This distinction is crucial for managing expectations and workflow."*

### 9.9. Standard MCP Integration Logic (Using Supabase as a Hub)
*AI Agent Directive: When implementing features requiring interaction with any Model Context Protocol (MCP) Server (for payments, AI/LLM calls, GitHub operations, messaging, etc.), you MUST follow the integration logic detailed below. This logic pattern is a general guideline. For each specific MCP, you may need to adapt parts of this logic (e.g., specific error handling, request/response transformation) based on its official documentation and the information provided by the human for its setup. Always prioritize the MCP's official documentation for implementation details, while adhering to our security and logging principles. The objective is to use our chosen backend (e.g., Supabase instance) as a central hub for configuration, interaction logging, and potentially storing MCP results, ensuring secure and traceable interaction with these external services.*

**9.9.1 Retrieve MCP Configuration from Supabase (if applicable):**
*   *AI Scenario:* Dynamic API keys, user/tenant-specific endpoints, or behavioral parameters for MCPs might be stored in tables within the chosen backend (e.g., Supabase tables like `mcp_configurations`, `user_service_credentials`).
*   *AI Action:*
    1.  Before calling an MCP, check if specific configurations are required and if they should be read from the chosen backend.
    2.  Implement code to query the chosen backend (e.g., using `supabase-js` client with appropriate RLS if Supabase is used) to retrieve these configurations.
    3.  Handle cases where configuration is not found or is invalid (e.g., log error, notify user/admin, fallback to default if safe).
*   *AI Example (Pseudo-code to guide implementation):*
    ```typescript
    // Within a Next.js API Route or Supabase Edge Function
    async function getMcpConfig(serviceName: string) { // Example assumes Supabase
      const { data: mcpConfig, error } = await chosenBackendClient // e.g., supabase
        .from('mcp_configurations') // or equivalent table in chosen DB
        .select('api_key, endpoint_url, other_params')
        .eq('service_name', serviceName)
        .single();
      if (error || !mcpConfig) {
        console.error(`Error fetching MCP config for ${serviceName}:`, error);
        throw new Error(`Configuration for ${serviceName} not found.`);
      }
      return mcpConfig;
    }
    // const { apiKey, endpointUrl } = await getMcpConfig('stripe_payment_mcp');
    ```

**9.9.2 Prepare Input Data for MCP:**
*   *AI Scenario:* The MCP expects specific input data, which may come from user requests, the chosen database, or application logic.
*   *AI Action:*
    1.  Gather and format the required input data for the MCP.
    2.  Validate this data rigorously before sending it to the MCP.
    3.  If necessary, retrieve additional contextual data from the chosen backend (e.g., Supabase) to enrich the MCP request.

**9.9.3 Secure MCP Call:**
*   *AI Scenario:* Interaction with the MCP typically occurs via an HTTP call to its endpoint.
*   *AI Action:*
    1.  Implement the HTTP call (using `fetch` or a robust library like `axios`) to the MCP endpoint.
    2.  Inject necessary authentication headers (e.g., `Authorization: Bearer <MCP_API_KEY>`). **Sensitive API keys MUST be stored securely as server-side environment variables (e.g., in Vercel settings or the chosen backend's environment settings like Supabase) and NEVER exposed client-side.**
    3.  Implement proper timeout handling and retry mechanisms for transient network errors if appropriate for the MCP's nature.
    4.  All MCP calls must originate from server-side environments (e.g., Next.js API Routes if used, or chosen backend functions like Supabase Edge Functions).

**9.9.4 Log MCP Interaction in Supabase (Audit Trail):**
*   *AI Scenario:* For traceability, debugging, and analytics, all MCP calls must be logged.
*   *AI Action:*
    1.  Before and/or after the MCP call, insert/update a record in a dedicated table in the chosen backend (e.g., a Supabase table like `mcp_interaction_logs`).
    2.  Log information such as: `timestamp`, `user_id` (if applicable), `mcp_name`, `request_payload_summary` (anonymize/truncate sensitive data), `response_status_code`, `response_summary_or_error_message`, `correlation_id` (generate a unique ID for each interaction flow).
*   *AI Example (Pseudo-code for backend table structure and logging, assuming Supabase):*
    ```sql
    -- mcp_interaction_logs table example
    CREATE TABLE mcp_interaction_logs (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        created_at TIMESTAMPTZ DEFAULT now(),
        user_id UUID REFERENCES auth.users(id),
        mcp_name TEXT NOT NULL,
        correlation_id UUID NOT NULL,
        status TEXT NOT NULL, -- e.g., 'initiated', 'success', 'failed_mcp', 'failed_internal'
        request_details JSONB, -- Summary, non-sensitive parts
        response_details JSONB, -- Summary, status code, non-sensitive parts or error message
        error_message TEXT
    );
    ```
    ```typescript
    // Logging example
    const correlationId = crypto.randomUUID(); // or a similar UUID generation
    await chosenBackendClient.from('mcp_interaction_logs').insert({ // Example assumes Supabase
        mcp_name: 'example_mcp',
        user_id: userId, // if applicable
        correlation_id: correlationId,
        status: 'initiated',
        request_details: { /* non-sensitive summary */ }
    });
    // ... MCP call ...
    // On response:
    await chosenBackendClient.from('mcp_interaction_logs') // Example assumes Supabase
        .update({
            status: mcpResponse.ok ? 'success' : 'failed_mcp', // or more granular status
            response_details: { statusCode: mcpResponse.status, /* non-sensitive summary */ },
            error_message: mcpResponse.ok ? null : await mcpResponse.text()
        })
        .eq('correlation_id', correlationId)
        .eq('status', 'initiated'); // Ensure updating the correct log
    ```

**9.9.5 Process MCP Response:**
*   *AI Scenario:* The MCP returns data or a status.
*   *AI Action:*
    1.  Parse the MCP's response (e.g., JSON).
    2.  Handle different HTTP status codes appropriately (2xx for success, 4xx for client errors, 5xx for server errors from the MCP).
    3.  Extract relevant data from the successful response. Log errors comprehensively.

**9.9.6 Update Supabase Database with MCP Results (if applicable):**
*   *AI Scenario:* MCP results may require creating, updating, or deleting data in the chosen backend (e.g., Supabase).
*   *AI Action:*
    1.  Implement logic to persist relevant MCP results into the appropriate tables in the chosen backend.
    2.  This could involve updating an order status, storing a transaction ID, saving AI-generated content, etc. Ensure data integrity and apply relevant security measures (like RLS if applicable).

**9.9.7 Provide Feedback to User / Application Flow:**
*   *AI Scenario:* The outcome of the MCP interaction needs to be communicated or influence the application flow.
*   *AI Action:*
    1.  Format an appropriate response for the frontend client or calling service.
    2.  Trigger subsequent actions in the application flow (e.g., redirect, display success/error message, update UI state).

**9.9.8 Key Considerations for AI Agent:**
*   **Security First:** Reiterate that MCP API keys and sensitive data are server-side only.
*   **Idempotency:** Where possible and supported by the MCP, implement idempotent calls for critical operations.
*   **Granular Error Handling:** Differentiate errors (MCP vs. chosen backend vs. internal logic) and provide clear feedback/logs.
*   **Modularity:** Encapsulate interaction logic for each MCP into reusable server-side functions/modules (e.g., in `/lib` or dedicated API routes/serverless functions within the chosen stack).
*   **Configuration Management:** For MCPs requiring user-specific setup (API keys, etc.), ensure the system allows users to provide these securely, and your code retrieves them from the designated secure storage (environment variables or a secure table in the chosen backend with appropriate security like RLS).

--- 